[1]Good afternoon, thank you for joining me today. In this presentation, we will explore the concept of differential upgrades and how they can significantly improve the efficiency 
and performance of embedded systems. Differential upgrades offer an innovative approach to the traditional upgrade process, let's delve into the details.

[2]Okay, these are today's topics. Background introduction->Theory of delta DFU->implement based on mcuboot->Demonstrator setup->test report.

[3]First, let's talk abot the background.
As we know, the ability to update device software Over-the-Air (OTA) is becoming increasingly important as more embedded devices get connected to the cloud, 
but embedded devices are limited by factors such as low bandwidth, small flash size, and battery power supply, which making OTA updates costly if they require sending 
large firmware (or other) images to these devices. So Delta DFU is a good solutions for embedded device since it only use the parts of the firmware that have changed, 
instead of downloading the whole firmware.

[4]And what is Delta DFU? 

Delta dfu is known as differential compression. For binary files, minor modifications to the source code can result in significant differences in the binary files, 
so the binary files generated by the differential algorithm is not too small compared to the source files, but it opens the door to using compression algorithms to 
generate delta file which can greatly reduced size of the delta file, this compressed file is called patch file. 
When application applying, it will decompress the patch first, then combine the source image to generate a new image.  
we can compare delta DFU with the standard full DFU, you see in addition to the complexity of the code, it has more advantages in all aspects.

But currently, there is not much differential upgrade solutions for small embedded systems. Even if some manufacturers implement it themselves, 
they only reduce the size of the upgrade file, and still need to provide a backup area to save the new image. This method only saves the download bandwidth, but also requires 
additional flash space to store patch files which is not the best choice in the flash limited embedded field; 
However, our solution solve the problem, let's discuss it in details.


[5]As mentioned earlier, delta DFU consists of a diff algorithm and a compression/decompression algorithm.
Our solution selects detools patching in combination with heatshrink algorithm, which can greatly reduce the size of the patch file by at least 60%.
BSDiff algorithm outputs the set of differences between two inputs which is called differential file, this file is easy to compress. 
Data compression algorithm is a process used to encode information using fewer bits than the original representation. we use heat-shrink as our conpress/decompress algorithm,
it comes in the forms of lossless compression which means that the compressed data will contain the same information as the uncompressed version.
I don't want to talk too much about the algorithm knowledge, BSDiff and heat-shrink are open source, if you want to know more details, you can refer to the corresponding 
documents on the official website.

[6]Patch generation is completed on the PC side, and the device side only needs to implement the patch applying process.
patch applying will decompress and apply the patch file package by package until the upgrade is completed.

[7]our solution can support a lot of bootloders, in order to keep consistent with NCS platform, I port it to the mcuboot. The flow chart shows the execution process of Delta DFU.
When start upgrade, device will download the patch file first, after patch file received, then verify it. If the patch file is correct, device will reboot to excute delta DFU,
otherwise the patch file will be deleted and device continue to excute the application.

[8] As I said, most solutions only reduce the size of the upgrade file, it does not save flash and even requires more flash to complete delta upgrades.
just like below chart, it needs to reserve a separate flash slot to save new generated image, it may also need another slot to save the patch file, 
so this method is not the best choice for the embedded field with limited flash resources. 

[9]our solution is like this, we save new image in the same flash area as old image without allocating a new flash slot. During applying, the old images will be erased first 
and then new images will be written in the same location, so it can save a lot of flash space while saving bandwidth and time. In this method, The first slot can be much larger 
than the second slot. 

[10]In order to apply with a single slot, we need to run applying operation twice. When applying for the first time, we didn't overwrite old image with new image, 
we just find out the old image segments which should be read out but has been overwritten by new image and save them to the backup area. 
After finish the first apply, then we restart the apply process and generate new image to overwrite the old image.

[11]This maybe difficult to understand, but it is the key point of this solution. Because during the applying process, we need to read patch files and old image package by package,
then overwrite the old image with the newly generated image file, but sometimes we need to adjust the position of the buffer reading from the old image, the position may 
have been overwritten by the newly generated image. so when applying for the first time, we find out these positions and save the package data in the backup area of Flash.

[12]let me show you an example. Here is an example of delta update from version 1 to version 2. The two applications are represented by the character sequences below for clarity.
[13]---[15] 
[16]---[40]





What technical problem(s) does the solution solve?

1. It greatly decrease the image size of update, it only need the parts of the firmware that have changed instead of the whole firmware which can save significant amounts 
   of time and bandwidth;

2. It improves the usability of flash since it is not necessary to reserve half of the flash to save the new image file, it only need a small flash size to save patch 
   file so that the application firmware can have more flash space;

3. mcuboot can support different slot size with this implement, so our NCS SDK can be used more flexible;



How does this idea differ from what is known? If there is more than one difference, please list them all and identify the most important.

1.  As I know, all delta upgrades currently need to evenly allocate flash space to store new and old image files, which greatly limits the use of flash. 
    Our solution does not need to do this. It only needs to allocate a much smaller flash space to store the patch file. The newly generated image will 
    be directly stored in the old image area, overwriting the old image, which can significantly save flash space.

2.  The upgrade process supports power down protection, and devices will only exit mcuboot after the upgrade is completed.

3.  The code is programmed in pure C language, independent of hardware, it is easy to migrate to various platforms.
